// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_spec.proto

#ifndef PROTOBUF_message_5fspec_2eproto__INCLUDED
#define PROTOBUF_message_5fspec_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace torps {
namespace ext {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_5fspec_2eproto();
void protobuf_AssignDesc_message_5fspec_2eproto();
void protobuf_ShutdownFile_message_5fspec_2eproto();

class NodeSpecification;
class LatencyInfo;
class CoordInit;
class Coordinate;
class CoordUpdate;
class ControlMessage;

enum Type {
  INIT = 1,
  GET = 2,
  COORDS = 3
};
bool Type_IsValid(int value);
const Type Type_MIN = INIT;
const Type Type_MAX = COORDS;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class NodeSpecification : public ::google::protobuf::Message {
 public:
  NodeSpecification();
  virtual ~NodeSpecification();

  NodeSpecification(const NodeSpecification& from);

  inline NodeSpecification& operator=(const NodeSpecification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeSpecification& default_instance();

  void Swap(NodeSpecification* other);

  // implements Message ----------------------------------------------

  NodeSpecification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeSpecification& from);
  void MergeFrom(const NodeSpecification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated double congestion_dist = 2;
  inline int congestion_dist_size() const;
  inline void clear_congestion_dist();
  static const int kCongestionDistFieldNumber = 2;
  inline double congestion_dist(int index) const;
  inline void set_congestion_dist(int index, double value);
  inline void add_congestion_dist(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      congestion_dist() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_congestion_dist();

  // @@protoc_insertion_point(class_scope:torps.ext.NodeSpecification)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedField< double > congestion_dist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static NodeSpecification* default_instance_;
};
// -------------------------------------------------------------------

class LatencyInfo : public ::google::protobuf::Message {
 public:
  LatencyInfo();
  virtual ~LatencyInfo();

  LatencyInfo(const LatencyInfo& from);

  inline LatencyInfo& operator=(const LatencyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatencyInfo& default_instance();

  void Swap(LatencyInfo* other);

  // implements Message ----------------------------------------------

  LatencyInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LatencyInfo& from);
  void MergeFrom(const LatencyInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 n1_idx = 1;
  inline bool has_n1_idx() const;
  inline void clear_n1_idx();
  static const int kN1IdxFieldNumber = 1;
  inline ::google::protobuf::uint32 n1_idx() const;
  inline void set_n1_idx(::google::protobuf::uint32 value);

  // required uint32 n2_idx = 2;
  inline bool has_n2_idx() const;
  inline void clear_n2_idx();
  static const int kN2IdxFieldNumber = 2;
  inline ::google::protobuf::uint32 n2_idx() const;
  inline void set_n2_idx(::google::protobuf::uint32 value);

  // required double latency = 3;
  inline bool has_latency() const;
  inline void clear_latency();
  static const int kLatencyFieldNumber = 3;
  inline double latency() const;
  inline void set_latency(double value);

  // @@protoc_insertion_point(class_scope:torps.ext.LatencyInfo)
 private:
  inline void set_has_n1_idx();
  inline void clear_has_n1_idx();
  inline void set_has_n2_idx();
  inline void clear_has_n2_idx();
  inline void set_has_latency();
  inline void clear_has_latency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 n1_idx_;
  ::google::protobuf::uint32 n2_idx_;
  double latency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static LatencyInfo* default_instance_;
};
// -------------------------------------------------------------------

class CoordInit : public ::google::protobuf::Message {
 public:
  CoordInit();
  virtual ~CoordInit();

  CoordInit(const CoordInit& from);

  inline CoordInit& operator=(const CoordInit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordInit& default_instance();

  void Swap(CoordInit* other);

  // implements Message ----------------------------------------------

  CoordInit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoordInit& from);
  void MergeFrom(const CoordInit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 update_interval_seconds = 1;
  inline bool has_update_interval_seconds() const;
  inline void clear_update_interval_seconds();
  static const int kUpdateIntervalSecondsFieldNumber = 1;
  inline ::google::protobuf::uint32 update_interval_seconds() const;
  inline void set_update_interval_seconds(::google::protobuf::uint32 value);

  // optional uint32 ping_interval_seconds = 2 [default = 3];
  inline bool has_ping_interval_seconds() const;
  inline void clear_ping_interval_seconds();
  static const int kPingIntervalSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 ping_interval_seconds() const;
  inline void set_ping_interval_seconds(::google::protobuf::uint32 value);

  // repeated .torps.ext.NodeSpecification node_data = 3;
  inline int node_data_size() const;
  inline void clear_node_data();
  static const int kNodeDataFieldNumber = 3;
  inline const ::torps::ext::NodeSpecification& node_data(int index) const;
  inline ::torps::ext::NodeSpecification* mutable_node_data(int index);
  inline ::torps::ext::NodeSpecification* add_node_data();
  inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >&
      node_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >*
      mutable_node_data();

  // repeated .torps.ext.LatencyInfo latency_map = 4;
  inline int latency_map_size() const;
  inline void clear_latency_map();
  static const int kLatencyMapFieldNumber = 4;
  inline const ::torps::ext::LatencyInfo& latency_map(int index) const;
  inline ::torps::ext::LatencyInfo* mutable_latency_map(int index);
  inline ::torps::ext::LatencyInfo* add_latency_map();
  inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >&
      latency_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >*
      mutable_latency_map();

  // @@protoc_insertion_point(class_scope:torps.ext.CoordInit)
 private:
  inline void set_has_update_interval_seconds();
  inline void clear_has_update_interval_seconds();
  inline void set_has_ping_interval_seconds();
  inline void clear_has_ping_interval_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 update_interval_seconds_;
  ::google::protobuf::uint32 ping_interval_seconds_;
  ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification > node_data_;
  ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo > latency_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static CoordInit* default_instance_;
};
// -------------------------------------------------------------------

class Coordinate : public ::google::protobuf::Message {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  void Swap(Coordinate* other);

  // implements Message ----------------------------------------------

  Coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required int32 dim = 2;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 2;
  inline ::google::protobuf::int32 dim() const;
  inline void set_dim(::google::protobuf::int32 value);

  // required double error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline double error() const;
  inline void set_error(double value);

  // repeated double vectors = 4;
  inline int vectors_size() const;
  inline void clear_vectors();
  static const int kVectorsFieldNumber = 4;
  inline double vectors(int index) const;
  inline void set_vectors(int index, double value);
  inline void add_vectors(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      vectors() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_vectors();

  // @@protoc_insertion_point(class_scope:torps.ext.Coordinate)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_dim();
  inline void clear_has_dim();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* node_id_;
  double error_;
  ::google::protobuf::RepeatedField< double > vectors_;
  ::google::protobuf::int32 dim_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static Coordinate* default_instance_;
};
// -------------------------------------------------------------------

class CoordUpdate : public ::google::protobuf::Message {
 public:
  CoordUpdate();
  virtual ~CoordUpdate();

  CoordUpdate(const CoordUpdate& from);

  inline CoordUpdate& operator=(const CoordUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordUpdate& default_instance();

  void Swap(CoordUpdate* other);

  // implements Message ----------------------------------------------

  CoordUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoordUpdate& from);
  void MergeFrom(const CoordUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .torps.ext.Coordinate coord = 1;
  inline int coord_size() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 1;
  inline const ::torps::ext::Coordinate& coord(int index) const;
  inline ::torps::ext::Coordinate* mutable_coord(int index);
  inline ::torps::ext::Coordinate* add_coord();
  inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >&
      coord() const;
  inline ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >*
      mutable_coord();

  // @@protoc_insertion_point(class_scope:torps.ext.CoordUpdate)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate > coord_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static CoordUpdate* default_instance_;
};
// -------------------------------------------------------------------

class ControlMessage : public ::google::protobuf::Message {
 public:
  ControlMessage();
  virtual ~ControlMessage();

  ControlMessage(const ControlMessage& from);

  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlMessage& default_instance();

  void Swap(ControlMessage* other);

  // implements Message ----------------------------------------------

  ControlMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlMessage& from);
  void MergeFrom(const ControlMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .torps.ext.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::torps::ext::Type type() const;
  inline void set_type(::torps::ext::Type value);

  // optional .torps.ext.CoordInit init_data = 2;
  inline bool has_init_data() const;
  inline void clear_init_data();
  static const int kInitDataFieldNumber = 2;
  inline const ::torps::ext::CoordInit& init_data() const;
  inline ::torps::ext::CoordInit* mutable_init_data();
  inline ::torps::ext::CoordInit* release_init_data();
  inline void set_allocated_init_data(::torps::ext::CoordInit* init_data);

  // optional .torps.ext.CoordUpdate update_data = 3;
  inline bool has_update_data() const;
  inline void clear_update_data();
  static const int kUpdateDataFieldNumber = 3;
  inline const ::torps::ext::CoordUpdate& update_data() const;
  inline ::torps::ext::CoordUpdate* mutable_update_data();
  inline ::torps::ext::CoordUpdate* release_update_data();
  inline void set_allocated_update_data(::torps::ext::CoordUpdate* update_data);

  // @@protoc_insertion_point(class_scope:torps.ext.ControlMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_init_data();
  inline void clear_has_init_data();
  inline void set_has_update_data();
  inline void clear_has_update_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::torps::ext::CoordInit* init_data_;
  ::torps::ext::CoordUpdate* update_data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static ControlMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// NodeSpecification

// required string id = 1;
inline bool NodeSpecification::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeSpecification::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeSpecification::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeSpecification::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& NodeSpecification::id() const {
  return *id_;
}
inline void NodeSpecification::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NodeSpecification::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NodeSpecification::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeSpecification::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* NodeSpecification::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeSpecification::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated double congestion_dist = 2;
inline int NodeSpecification::congestion_dist_size() const {
  return congestion_dist_.size();
}
inline void NodeSpecification::clear_congestion_dist() {
  congestion_dist_.Clear();
}
inline double NodeSpecification::congestion_dist(int index) const {
  return congestion_dist_.Get(index);
}
inline void NodeSpecification::set_congestion_dist(int index, double value) {
  congestion_dist_.Set(index, value);
}
inline void NodeSpecification::add_congestion_dist(double value) {
  congestion_dist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
NodeSpecification::congestion_dist() const {
  return congestion_dist_;
}
inline ::google::protobuf::RepeatedField< double >*
NodeSpecification::mutable_congestion_dist() {
  return &congestion_dist_;
}

// -------------------------------------------------------------------

// LatencyInfo

// required uint32 n1_idx = 1;
inline bool LatencyInfo::has_n1_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatencyInfo::set_has_n1_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatencyInfo::clear_has_n1_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatencyInfo::clear_n1_idx() {
  n1_idx_ = 0u;
  clear_has_n1_idx();
}
inline ::google::protobuf::uint32 LatencyInfo::n1_idx() const {
  return n1_idx_;
}
inline void LatencyInfo::set_n1_idx(::google::protobuf::uint32 value) {
  set_has_n1_idx();
  n1_idx_ = value;
}

// required uint32 n2_idx = 2;
inline bool LatencyInfo::has_n2_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatencyInfo::set_has_n2_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatencyInfo::clear_has_n2_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatencyInfo::clear_n2_idx() {
  n2_idx_ = 0u;
  clear_has_n2_idx();
}
inline ::google::protobuf::uint32 LatencyInfo::n2_idx() const {
  return n2_idx_;
}
inline void LatencyInfo::set_n2_idx(::google::protobuf::uint32 value) {
  set_has_n2_idx();
  n2_idx_ = value;
}

// required double latency = 3;
inline bool LatencyInfo::has_latency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LatencyInfo::set_has_latency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LatencyInfo::clear_has_latency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LatencyInfo::clear_latency() {
  latency_ = 0;
  clear_has_latency();
}
inline double LatencyInfo::latency() const {
  return latency_;
}
inline void LatencyInfo::set_latency(double value) {
  set_has_latency();
  latency_ = value;
}

// -------------------------------------------------------------------

// CoordInit

// required uint32 update_interval_seconds = 1;
inline bool CoordInit::has_update_interval_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordInit::set_has_update_interval_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordInit::clear_has_update_interval_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordInit::clear_update_interval_seconds() {
  update_interval_seconds_ = 0u;
  clear_has_update_interval_seconds();
}
inline ::google::protobuf::uint32 CoordInit::update_interval_seconds() const {
  return update_interval_seconds_;
}
inline void CoordInit::set_update_interval_seconds(::google::protobuf::uint32 value) {
  set_has_update_interval_seconds();
  update_interval_seconds_ = value;
}

// optional uint32 ping_interval_seconds = 2 [default = 3];
inline bool CoordInit::has_ping_interval_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoordInit::set_has_ping_interval_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoordInit::clear_has_ping_interval_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoordInit::clear_ping_interval_seconds() {
  ping_interval_seconds_ = 3u;
  clear_has_ping_interval_seconds();
}
inline ::google::protobuf::uint32 CoordInit::ping_interval_seconds() const {
  return ping_interval_seconds_;
}
inline void CoordInit::set_ping_interval_seconds(::google::protobuf::uint32 value) {
  set_has_ping_interval_seconds();
  ping_interval_seconds_ = value;
}

// repeated .torps.ext.NodeSpecification node_data = 3;
inline int CoordInit::node_data_size() const {
  return node_data_.size();
}
inline void CoordInit::clear_node_data() {
  node_data_.Clear();
}
inline const ::torps::ext::NodeSpecification& CoordInit::node_data(int index) const {
  return node_data_.Get(index);
}
inline ::torps::ext::NodeSpecification* CoordInit::mutable_node_data(int index) {
  return node_data_.Mutable(index);
}
inline ::torps::ext::NodeSpecification* CoordInit::add_node_data() {
  return node_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >&
CoordInit::node_data() const {
  return node_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >*
CoordInit::mutable_node_data() {
  return &node_data_;
}

// repeated .torps.ext.LatencyInfo latency_map = 4;
inline int CoordInit::latency_map_size() const {
  return latency_map_.size();
}
inline void CoordInit::clear_latency_map() {
  latency_map_.Clear();
}
inline const ::torps::ext::LatencyInfo& CoordInit::latency_map(int index) const {
  return latency_map_.Get(index);
}
inline ::torps::ext::LatencyInfo* CoordInit::mutable_latency_map(int index) {
  return latency_map_.Mutable(index);
}
inline ::torps::ext::LatencyInfo* CoordInit::add_latency_map() {
  return latency_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >&
CoordInit::latency_map() const {
  return latency_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >*
CoordInit::mutable_latency_map() {
  return &latency_map_;
}

// -------------------------------------------------------------------

// Coordinate

// required string node_id = 1;
inline bool Coordinate::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coordinate::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coordinate::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coordinate::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& Coordinate::node_id() const {
  return *node_id_;
}
inline void Coordinate::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Coordinate::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Coordinate::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Coordinate::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* Coordinate::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Coordinate::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 dim = 2;
inline bool Coordinate::has_dim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Coordinate::set_has_dim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Coordinate::clear_has_dim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Coordinate::clear_dim() {
  dim_ = 0;
  clear_has_dim();
}
inline ::google::protobuf::int32 Coordinate::dim() const {
  return dim_;
}
inline void Coordinate::set_dim(::google::protobuf::int32 value) {
  set_has_dim();
  dim_ = value;
}

// required double error = 3;
inline bool Coordinate::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Coordinate::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Coordinate::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Coordinate::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline double Coordinate::error() const {
  return error_;
}
inline void Coordinate::set_error(double value) {
  set_has_error();
  error_ = value;
}

// repeated double vectors = 4;
inline int Coordinate::vectors_size() const {
  return vectors_.size();
}
inline void Coordinate::clear_vectors() {
  vectors_.Clear();
}
inline double Coordinate::vectors(int index) const {
  return vectors_.Get(index);
}
inline void Coordinate::set_vectors(int index, double value) {
  vectors_.Set(index, value);
}
inline void Coordinate::add_vectors(double value) {
  vectors_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Coordinate::vectors() const {
  return vectors_;
}
inline ::google::protobuf::RepeatedField< double >*
Coordinate::mutable_vectors() {
  return &vectors_;
}

// -------------------------------------------------------------------

// CoordUpdate

// repeated .torps.ext.Coordinate coord = 1;
inline int CoordUpdate::coord_size() const {
  return coord_.size();
}
inline void CoordUpdate::clear_coord() {
  coord_.Clear();
}
inline const ::torps::ext::Coordinate& CoordUpdate::coord(int index) const {
  return coord_.Get(index);
}
inline ::torps::ext::Coordinate* CoordUpdate::mutable_coord(int index) {
  return coord_.Mutable(index);
}
inline ::torps::ext::Coordinate* CoordUpdate::add_coord() {
  return coord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >&
CoordUpdate::coord() const {
  return coord_;
}
inline ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >*
CoordUpdate::mutable_coord() {
  return &coord_;
}

// -------------------------------------------------------------------

// ControlMessage

// required .torps.ext.Type type = 1;
inline bool ControlMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::torps::ext::Type ControlMessage::type() const {
  return static_cast< ::torps::ext::Type >(type_);
}
inline void ControlMessage::set_type(::torps::ext::Type value) {
  assert(::torps::ext::Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .torps.ext.CoordInit init_data = 2;
inline bool ControlMessage::has_init_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlMessage::set_has_init_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlMessage::clear_has_init_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlMessage::clear_init_data() {
  if (init_data_ != NULL) init_data_->::torps::ext::CoordInit::Clear();
  clear_has_init_data();
}
inline const ::torps::ext::CoordInit& ControlMessage::init_data() const {
  return init_data_ != NULL ? *init_data_ : *default_instance_->init_data_;
}
inline ::torps::ext::CoordInit* ControlMessage::mutable_init_data() {
  set_has_init_data();
  if (init_data_ == NULL) init_data_ = new ::torps::ext::CoordInit;
  return init_data_;
}
inline ::torps::ext::CoordInit* ControlMessage::release_init_data() {
  clear_has_init_data();
  ::torps::ext::CoordInit* temp = init_data_;
  init_data_ = NULL;
  return temp;
}
inline void ControlMessage::set_allocated_init_data(::torps::ext::CoordInit* init_data) {
  delete init_data_;
  init_data_ = init_data;
  if (init_data) {
    set_has_init_data();
  } else {
    clear_has_init_data();
  }
}

// optional .torps.ext.CoordUpdate update_data = 3;
inline bool ControlMessage::has_update_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlMessage::set_has_update_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlMessage::clear_has_update_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlMessage::clear_update_data() {
  if (update_data_ != NULL) update_data_->::torps::ext::CoordUpdate::Clear();
  clear_has_update_data();
}
inline const ::torps::ext::CoordUpdate& ControlMessage::update_data() const {
  return update_data_ != NULL ? *update_data_ : *default_instance_->update_data_;
}
inline ::torps::ext::CoordUpdate* ControlMessage::mutable_update_data() {
  set_has_update_data();
  if (update_data_ == NULL) update_data_ = new ::torps::ext::CoordUpdate;
  return update_data_;
}
inline ::torps::ext::CoordUpdate* ControlMessage::release_update_data() {
  clear_has_update_data();
  ::torps::ext::CoordUpdate* temp = update_data_;
  update_data_ = NULL;
  return temp;
}
inline void ControlMessage::set_allocated_update_data(::torps::ext::CoordUpdate* update_data) {
  delete update_data_;
  update_data_ = update_data;
  if (update_data) {
    set_has_update_data();
  } else {
    clear_has_update_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ext
}  // namespace torps

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::torps::ext::Type>() {
  return ::torps::ext::Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_5fspec_2eproto__INCLUDED

*** Function called by timer ***
run_scheduled_events() [main.c]
-> circuit_build_needed_circs() [circuituse.c]
  -> connection_ap_attach_pending()
    -> connection_ap_handshake_attach_circuit()
      -> circuit_get_open_circ_or_launch(conn, CIRCUIT_PURPOSE_C_GENERAL, &circ)
        -> circuit_get_best(conn, 1, desired_circuit_purpose, need_uptime, need_internal)
          -> circuit_is_acceptable(origin_circ,conn,must_be_open,purpose, need_uptime,need_internal,now.tv_sec)
            -> connection_ap_can_use_exit(conn, exitnode)
          -> circuit_is_better(origin_circ,best,conn)
            -> connection_edge_update_circuit_isolation(conn, (origin_circuit_t*)oa, 1)
        -> circuit_get_best(conn, 0, desired_circuit_purpose, need_uptime, need_internal) [previous call found no circuit, checks for one "on the way"]
      -> circuit_log_path(LOG_INFO,LD_APP|LD_CIRC,circ)
  -> circuit_expire_old_circuits_clientside()
  -> circuit_predict_and_launch_new() [circuituse.c]
    -> circuit_all_predicted_ports_handled(now, &port_needs_uptime, &port_needs_capacity)
      -> circuit_get_unhandled_ports(now)
        -> rep_hist_get_predicted_ports(now)
        -> circuit_remove_handled_ports(dest)
          -> circuit_stream_is_being_handled(NULL, *port, MIN_CIRCUITS_HANDLING_STREAM)
            -> compare_tor_addr_to_node_policy(NULL, port, exitnode)
              -> compare_tor_addr_to_addr_policy(addr, port, node->ri->exit_policy)
                -> compare_unknown_tor_addr_to_addr_policy(port, policy)
                -> compare_known_tor_addr_to_addr_policy_noport(addr, policy)
                -> compare_known_tor_addr_to_addr_policy(addr, port, policy)
    -> circuit_launch(CIRCUIT_PURPOSE_C_GENERAL, flags) [circuituse.c]
      -> circuit_launch_by_extend_info(purpose, NULL, flags) [circuituse.c]
        -> circuit_establish_circuit(purpose, extend_info, flags) (here extend_info is NULL) [circuitbuild.c]
          -> onion_pick_cpath_exit(circ, exit)
            -> choose_good_exit_server(circ->base_.purpose, state->need_uptime, state->need_capacity, state->is_internal)
              -> node_handles_some_port(node, needed_ports)
          -> onion_populate_cpath(circ)

*** Function called when new SOCKS cxn made ***
[connection_ap_rewrite_and_attach_if_allowed usually used to call connection_ap_handshake_rewrite_and_attach]
connection_ap_handshake_rewrite_and_attach(entry_connection_t *conn, origin_circuit_t *circ, crypt_path_t *cpath)
  -> rep_hist_note_used_resolve(now) [for SOCKS_COMMAND_RESOLVE]
    -> rep_hist_note_used_port(now, 80)
  -> rep_hist_note_used_port(now, socks->port) [for SOCKS_COMMAND_CONNECT]
  -> rep_hist_note_used_resolve(now) [for SOCKS_COMMAND_RESOLVE_PTR]
  -> connection_ap_handshake_attach_circuit(conn)
    -> circuit_get_open_circ_or_launch(conn, CIRCUIT_PURPOSE_C_GENERAL, &circ)
      -> circuit_get_best(conn, 1, desired_circuit_purpose, need_uptime, need_internal) [is a suitable circuit already open?]
      -> circ = circuit_get_best(conn, 0, desired_circuit_purpose, need_uptime, need_internal) [check for one "on the way"]
        -> circuit_is_acceptable(origin_circ,conn,must_be_open,purpose, need_uptime,need_internal,now.tv_sec) [circuituse.c]
          -> connection_ap_can_use_exit(conn, exitnode)
            -> compare_tor_addr_to_node_policy(addrp, conn->socks_request->port,exit) [policies.c]
              -> compare_tor_addr_to_addr_policy(addr, port, node->ri->exit_policy) [policies.c]
        -> circuit_is_better(origin_circ,best,conn)
    -> connection_ap_handshake_attach_chosen_circuit(conn, circ, NULL)
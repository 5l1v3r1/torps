run_scheduled_events() [main.c]
-> circuit_build_needed_circs() [circuituse.c]
  -> circuit_predict_and_launch_new()
    -> circuit_launch()
      -> circuit_launch_by_extend_info()
        -> circuit_establish_circuit() [circuitbuild.c]
          -> onion_pick_cpath_exit()
            -> choose_good_exit_server(circ->base_.purpose, state->need_uptime,
                              state->need_capacity, state->is_internal);
                -> [internal]: router_choose_random_node()
                -> [exit]: choose_good_exit_server_general()
          -> onion_populate_cpath()
            -> onion_extend_cpath()
              -> [cur_len == 0]: choose_good_entry_server(purpose, state) where state is non-null
                -> [state != NULL]: choose_random_entry(state) where state is non-null
                  -> choose_random_entry_impl(state, 0, 0) where state is non-null
                    -> pick_entry_guards(options, for_directory) where for_directory = 0. (checks liveness, adds some until num_live_entry_guards is num_needed, which itself weirdly calls entry_is_live(entry, 0, 1, 0, !for_directory, &msg), where that fn sig is entry_is_live(entry_guard_t *e, int need_uptime, int need_capacity, int assume_reachable, int need_descriptor, const char **msg)), i.e. uptime flag permanently unset, capacity permanently set.
                      -> add_an_entry_guard(NULL, 0, 0, for_directory)
                        -> choose_good_entry_server((CIRCUIT_PURPOSE_C_GENERAL,
                                                    NULL)
                          -> router_choose_random_node() (no up/cap/val flags)
                    -> [if live_num < preferred_min]: add_an_entry_guard(NULL, 
                                                        0, 0, for_directory);
                      -> choose_good_entry_server(CIRCUIT_PURPOSE_C_GENERAL,
                                                    NULL)
                -> [else]: router_choose_random_node(excluded, 
                            options->ExcludeNodes, flags)
              -> [desired_path_len > cur_len > 0]: choose_good_middle_server()
              
***** setting status on receipt of a new descriptor *****
entry_guards_compute_status
  -> entry_guard_set_status(entry, r, now, options, &reason)
  -> remove_dead_entry_guards(now)
  -> remove_obsolete_entry_guards(now)
  -> entry_is_live(entry, 0, 1, 0, 0, &live_msg)
  -> entry_guards_changed()